#!/bin/sh

# tts - Text-to-speech CLI using ElevenLabs API
# Reads text from stdin and outputs audio to stdout

# Default values
API_KEY="${ELEVENLABS_API_KEY:-}"
VOICE_ID="${TTS_VOICE_ID:-21m00Tcm4TlvDq8ikWAM}"  # Default to Rachel voice
MODEL_ID="${TTS_MODEL_ID:-eleven_monolingual_v1}"
OUTPUT_FORMAT="${TTS_OUTPUT_FORMAT:-mp3_44100_128}"
API_URL="https://api.elevenlabs.io/v1/text-to-speech"
DEBUG="${TTS_DEBUG:-}"
CHUNK_SIZE="${TTS_CHUNK_SIZE:-5000}"  # Characters per chunk for streaming
PLAY_AUDIO=""  # Play audio directly instead of outputting to stdout
OPTIMIZE_STREAMING_LATENCY="${TTS_OPTIMIZE_STREAMING_LATENCY:-1}"  # 0-4, higher = lower latency

# Parse command line options
while [ "$#" -gt 0 ]; do
    case "$1" in
        -k|--api-key)
            API_KEY="$2"
            shift 2
            ;;
        -v|--voice)
            VOICE_ID="$2"
            shift 2
            ;;
        -m|--model)
            MODEL_ID="$2"
            shift 2
            ;;
        -f|--format)
            OUTPUT_FORMAT="$2"
            shift 2
            ;;
        -d|--debug)
            DEBUG=1
            shift
            ;;
        -c|--chunk-size)
            CHUNK_SIZE="$2"
            shift 2
            ;;
        -p|--play)
            PLAY_AUDIO=1
            shift
            ;;
        -l|--latency)
            OPTIMIZE_STREAMING_LATENCY="$2"
            shift 2
            ;;
        -h|--help)
            cat >&2 <<EOF
Usage: tts [OPTIONS] < input.txt > output.mp3

Convert text to speech using ElevenLabs API.

OPTIONS:
    -k, --api-key KEY      ElevenLabs API key (or set ELEVENLABS_API_KEY)
    -v, --voice ID         Voice ID (default: 21m00Tcm4TlvDq8ikWAM)
    -m, --model ID         Model ID (default: eleven_monolingual_v1)
    -f, --format FORMAT    Output format (default: mp3_44100_128)
    -c, --chunk-size SIZE  Characters per chunk for streaming (default: 5000)
    -d, --debug           Enable debug output
    -p, --play            Play audio directly (macOS only)
    -l, --latency LEVEL   Optimize streaming latency 0-4 (default: 1)
    -h, --help            Show this help message

EXAMPLES:
    echo "Hello world" | tts > hello.mp3
    cat book.txt | tts -v EXAVITQu4vr4xnSDxMaL > book.mp3
    tts < story.txt | mpv -
    
    # Play audio directly (macOS)
    echo "Hello world" | tts --play
    
    # Process large files with streaming
    cat large_book.txt | tts -c 10000 > book.mp3
    
    # Debug API issues
    echo "test" | tts -d > test.mp3

ENVIRONMENT VARIABLES:
    ELEVENLABS_API_KEY              Default API key
    TTS_VOICE_ID                   Default voice ID
    TTS_MODEL_ID                   Default model ID
    TTS_OUTPUT_FORMAT              Default output format
    TTS_DEBUG                      Enable debug output (set to 1)
    TTS_CHUNK_SIZE                 Default chunk size for streaming
    TTS_OPTIMIZE_STREAMING_LATENCY Default latency optimization (0-4)
EOF
            exit 0
            ;;
        *)
            echo "Error: Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Debug function
debug() {
    if [ -n "$DEBUG" ]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Check for API key
if [ -z "$API_KEY" ]; then
    echo "Error: API key required. Set ELEVENLABS_API_KEY or use -k option." >&2
    exit 1
fi

debug "API Key: ${API_KEY:0:10}..."
debug "Voice ID: $VOICE_ID"
debug "Model ID: $MODEL_ID"
debug "Output Format: $OUTPUT_FORMAT"
debug "Chunk Size: $CHUNK_SIZE"
debug "Optimize Streaming Latency: $OPTIMIZE_STREAMING_LATENCY"

# Escape text for JSON
escape_json() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr '\n' ' ' | sed 's/  */ /g'
}

# Process a single chunk of text
process_chunk() {
    local text="$1"
    local chunk_num="$2"
    
    if [ -z "$text" ]; then
        return 0
    fi
    
    debug "Processing chunk $chunk_num (${#text} chars)"
    
    local escaped_text=$(escape_json "$text")
    local temp_file=$(mktemp)
    
    # Create request body
    cat > "$temp_file" <<EOF
{
    "text": "$escaped_text",
    "model_id": "$MODEL_ID",
    "voice_settings": {
        "stability": 0.5,
        "similarity_boost": 0.75
    },
    "output_format": "$OUTPUT_FORMAT"
}
EOF
    
    if [ -n "$DEBUG" ]; then
        debug "Request body:"
        cat "$temp_file" >&2
    fi
    
    # Make API request with streaming support
    if [ -n "$PLAY_AUDIO" ]; then
        # Stream to file and play when ready
        if command -v afplay >/dev/null 2>&1; then
            # Download to temp file
            local audio_temp=$(mktemp).mp3
            local headers_file=$(mktemp)
            local http_code=$(curl -w "%{http_code}" -o "$audio_temp" -D "$headers_file" -X POST \
                "${API_URL}/${VOICE_ID}/stream?optimize_streaming_latency=${OPTIMIZE_STREAMING_LATENCY}" \
                -H "Content-Type: application/json" \
                -H "xi-api-key: ${API_KEY}" \
                -d "@$temp_file" \
                $([ -n "$DEBUG" ] && echo "-v") \
                2>"${temp_file}.err")
            
            local curl_exit=$?
            
            # Check curl exit code
            if [ $curl_exit -ne 0 ]; then
                echo "Error: curl failed with exit code $curl_exit" >&2
                if [ -n "$DEBUG" ] && [ -f "${temp_file}.err" ]; then
                    echo "Curl error output:" >&2
                    cat "${temp_file}.err" >&2
                fi
                rm -f "$temp_file" "${temp_file}.err" "$audio_temp" "$headers_file"
                return 1
            fi
            
            # Check HTTP response
            if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
                # Play the audio file
                afplay "$audio_temp"
                rm -f "$temp_file" "${temp_file}.err" "$audio_temp" "$headers_file"
                return 0
            else
                echo "Error: API request failed (HTTP $http_code)" >&2
                rm -f "$temp_file" "${temp_file}.err" "$audio_temp" "$headers_file"
                return 1
            fi
        else
            echo "Error: afplay not found. --play option requires macOS." >&2
            rm -f "$temp_file"
            return 1
        fi
    else
        # Standard mode: save to file then output
        local response_file=$(mktemp)
        local headers_file=$(mktemp)
        local http_code=$(curl -w "%{http_code}" -o "$response_file" -D "$headers_file" -X POST \
            "${API_URL}/${VOICE_ID}/stream?optimize_streaming_latency=${OPTIMIZE_STREAMING_LATENCY}" \
            -H "Content-Type: application/json" \
            -H "xi-api-key: ${API_KEY}" \
            -d "@$temp_file" \
            $([ -n "$DEBUG" ] && echo "-v") \
            2>"${temp_file}.err")
        
        local curl_exit=$?
        
        # Check curl exit code
        if [ $curl_exit -ne 0 ]; then
            echo "Error: curl failed with exit code $curl_exit" >&2
            if [ -n "$DEBUG" ] && [ -f "${temp_file}.err" ]; then
                echo "Curl error output:" >&2
                cat "${temp_file}.err" >&2
            fi
            rm -f "$temp_file" "${temp_file}.err" "$response_file"
            return 1
        fi
        
        # Check HTTP response
        if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
            # Output the audio data to stdout
            cat "$response_file"
            rm -f "$temp_file" "${temp_file}.err" "$response_file" "$headers_file"
            return 0
        else
            # Error - show details
            echo "Error: API request failed (HTTP $http_code)" >&2
            
            # Show response headers for debugging
            if [ -n "$DEBUG" ] && [ -f "$headers_file" ]; then
                echo "Response headers:" >&2
                cat "$headers_file" >&2
            fi
            
            if [ -s "$response_file" ]; then
                echo "Response body:" >&2
                cat "$response_file" >&2
            fi
            
            if [ -n "$DEBUG" ] && [ -f "${temp_file}.err" ]; then
                echo "Curl debug output:" >&2
                cat "${temp_file}.err" >&2
            fi
            
            # Common error explanations
            case "$http_code" in
                401)
                    echo "Hint: Authentication failed. Check your API key." >&2
                    ;;
                403)
                    echo "Hint: Access forbidden. API key may lack permissions." >&2
                    ;;
                404)
                    echo "Hint: Voice ID '$VOICE_ID' not found." >&2
                    ;;
                429)
                    echo "Hint: Rate limit exceeded. Try again later." >&2
                    ;;
                500|502|503)
                    echo "Hint: Server error. ElevenLabs API may be down." >&2
                    ;;
            esac
            
            rm -f "$temp_file" "${temp_file}.err" "$response_file" "$headers_file"
            return 1
        fi
    fi
}

# Read and process input in chunks
chunk_buffer=""
chunk_count=0
total_chars=0

# Process stdin line by line for better streaming
# Handle both regular lines and lines without final newline
while IFS= read -r line || [ -n "$line" ]; do
    # Add line to buffer with space (preserving word boundaries)
    if [ -n "$chunk_buffer" ]; then
        chunk_buffer="$chunk_buffer $line"
    else
        chunk_buffer="$line"
    fi
    
    # Check if buffer exceeds chunk size
    if [ ${#chunk_buffer} -ge "$CHUNK_SIZE" ]; then
        chunk_count=$((chunk_count + 1))
        total_chars=$((total_chars + ${#chunk_buffer}))
        
        if ! process_chunk "$chunk_buffer" "$chunk_count"; then
            exit 1
        fi
        
        chunk_buffer=""
    fi
done

# Process any remaining text
if [ -n "$chunk_buffer" ]; then
    chunk_count=$((chunk_count + 1))
    total_chars=$((total_chars + ${#chunk_buffer}))
    
    if ! process_chunk "$chunk_buffer" "$chunk_count"; then
        exit 1
    fi
fi

# Check if any text was processed
if [ $chunk_count -eq 0 ]; then
    echo "Error: No input text provided." >&2
    exit 1
fi

debug "Processed $chunk_count chunks, $total_chars total characters"